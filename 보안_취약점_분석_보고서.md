# 보안 취약점 분석 보고서

**분석 일자**: 2026-02-12  
**최종 업데이트**: 2026-02-14 (공개 API·인증 분리 코드 반영)  
**분석 대상**: Backend (FastAPI) 및 Frontend (React) 소스코드  
**분석 범위**: 인증/인가, 입력 검증, SQL Injection, XSS, CSRF, 환경 변수 관리, 에러 처리, **공개 API 및 인증 분리**

---

## 📋 요약

전반적으로 **양호한 보안 수준**을 유지하고 있으나, 몇 가지 **중요한 개선 사항**이 필요합니다.

### ✅ 잘 구현된 보안 기능
- SQL Injection 방지 (SQLAlchemy ORM 사용)
- 비밀번호 해싱 (bcrypt)
- JWT 토큰 기반 인증
- Pydantic을 통한 입력 검증
- 권한 확인 (사용자별 데이터 접근 제어)
- **공개 API와 인증 API 분리**: 공개 북마크 전용 엔드포인트(`/api/public/bookmarks`)는 인증 의존성 없이 제공되며, 인증 경로와 명확히 구분됨

### ⚠️ 개선이 필요한 보안 이슈
1. **높은 우선순위**: 환경 변수 파일(.env) Git 관리
2. **중간 우선순위**: 에러 메시지 정보 노출, 디버깅 코드 제거
3. **낮은 우선순위**: 토큰 저장 방식 개선, CSRF 보호 강화
4. **공개 API**: rate limiting 미적용으로 스크래핑·남용 가능성 (권장: 제한 도입)

---

## 🔍 상세 분석

### 1. SQL Injection 방지 ✅

**상태**: **안전**

**분석**:
- SQLAlchemy ORM을 사용하여 파라미터화된 쿼리 자동 생성
- 모든 데이터베이스 쿼리가 ORM을 통해 실행됨
- 직접 SQL 문자열 조작 없음

**코드 예시**:
```python
# backend/app/crud/crud_bookmark.py
user = db.query(User).filter(User.username == username).first()
bookmarks = db.query(Bookmark).filter(Bookmark.user_id == owner_id).all()
```

**결론**: SQL Injection 취약점 없음

---

### 2. 인증 및 인가 ✅

**상태**: **안전**

**분석**:
- **비밀번호 해싱**: bcrypt 사용 (`passlib.context.CryptContext`)
- **JWT 토큰**: HS256 알고리즘 사용
- **세션 관리**: 데이터베이스에 세션 저장 및 검증
- **권한 확인**: 인증이 필요한 엔드포인트(`/api/bookmarks`, `/api/auth/me` 등)에서만 `get_current_user` 사용. 공개 전용 경로(`/api/public/bookmarks`)는 인증 의존성 없이 분리됨.
- **권한 확인**: 인증용 CRUD 작업에서 사용자 ID 확인 (수정/삭제 시 403)

**코드 예시**:
```python
# backend/app/core/security.py
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
access_token = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)

# backend/app/api/endpoints/bookmarks.py
if bookmark.user_id != current_user.id:
    raise HTTPException(status_code=403, detail="권한 없음")
```

**결론**: 인증/인가 메커니즘 적절히 구현됨

---

### 3. 입력 검증 ✅

**상태**: **안전**

**분석**:
- Pydantic 스키마를 통한 자동 검증
- URL 유효성 검사 (`HttpUrl` 타입)
- 타입 검증 및 필수 필드 확인

**코드 예시**:
```python
# backend/app/schemas/bookmark.py
class BookmarkCreate(BaseModel):
    url: HttpUrl  # 자동 URL 검증
    title: Optional[str] = None
    tags: Optional[List[str]] = []
```

**결론**: 입력 검증 적절히 구현됨

---

### 4. XSS (Cross-Site Scripting) 방지 ✅

**상태**: **안전**

**분석**:
- React의 기본 이스케이핑 사용
- `dangerouslySetInnerHTML` 사용 없음
- 마크다운 렌더링 시 `react-markdown` 사용 (안전한 라이브러리)

**결론**: XSS 취약점 없음

---

### 5. 환경 변수 관리 ⚠️

**상태**: **주의 필요**

**발견된 문제**:
1. `.gitignore` 파일이 없거나 `.env` 파일이 Git에 포함될 위험
2. `.env` 파일에 민감한 정보 포함:
   - 데이터베이스 비밀번호
   - JWT SECRET_KEY
   - 관리자 계정 정보

**위험도**: **높음**

**권장 조치**:
```bash
# .gitignore 파일 생성 필요
backend/.env
frontend/.env
*.log
__pycache__/
*.pyc
.env.local
.env.*.local
```

**즉시 조치 필요**: `.gitignore` 파일 생성 및 `.env` 파일이 Git에 포함되지 않았는지 확인

---

### 6. 에러 처리 및 정보 노출 ⚠️

**상태**: **개선 필요**

**발견된 문제**:
1. 일부 에러 메시지에서 상세한 스택 트레이스 노출 가능성
2. 디버깅 코드가 프로덕션에 포함됨

**코드 예시**:
```python
# backend/app/main.py (48-54줄)
@app.middleware("http")
async def debug_cors(request, call_next):
    print(f"Incoming request from origin: {request.headers.get('origin')}")
    response = await call_next(request)
    print(f"Response headers: {dict(response.headers)}")
    return response
```

**위험도**: **중간**

**권장 조치**:
1. 프로덕션 환경에서는 디버깅 미들웨어 제거
2. 에러 응답에서 상세한 스택 트레이스 제거
3. 환경 변수로 디버그 모드 제어

**개선 예시**:
```python
# 환경 변수 추가
DEBUG = os.getenv("DEBUG", "False").lower() == "true"

# 디버깅 코드 조건부 실행
if DEBUG:
    @app.middleware("http")
    async def debug_cors(request, call_next):
        ...
```

---

### 7. 토큰 저장 방식 ⚠️

**상태**: **개선 권장**

**현재 구현**:
- JWT 토큰을 `localStorage`에 저장
- XSS 공격 시 토큰 탈취 가능성

**코드 예시**:
```javascript
// frontend/src/utils/api.js
localStorage.setItem('token', response.data.access_token);
```

**위험도**: **낮음** (XSS 방지가 잘 되어 있으므로)

**권장 조치**:
- 현재 구현도 충분히 안전하지만, 추가 보안을 위해:
  1. `httpOnly` 쿠키 사용 고려 (CSRF 토큰과 함께)
  2. 토큰 만료 시간 단축 (현재 30분)
  3. Refresh Token 도입 고려

---

### 8. CORS 설정 ✅

**상태**: **적절**

**분석**:
- 특정 도메인만 허용 (화이트리스트 방식)
- `allow_credentials=True` 설정
- 개발 및 프로덕션 환경 모두 포함

**코드 예시**:
```python
# backend/app/main.py
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.BACKEND_CORS_ORIGINS,  # 특정 도메인만 허용
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

**개선 권장**:
- 프로덕션에서는 `allow_methods`와 `allow_headers`를 필요한 것만 명시적으로 지정

---

### 9. CSRF 보호 ⚠️

**상태**: **개선 권장**

**현재 상태**:
- JWT 토큰 기반 인증 사용
- CSRF 토큰 미사용

**위험도**: **낮음** (JWT는 CSRF에 상대적으로 안전)

**권장 조치**:
- 추가 보안을 위해 CSRF 토큰 도입 고려
- 또는 SameSite 쿠키 속성 사용 (쿠키 방식으로 전환 시)

---

### 10. 로깅 및 민감 정보 ⚠️

**상태**: **주의 필요**

**발견된 문제**:
- 로그에 Authorization 헤더 제외 처리됨 ✅
- 하지만 일부 로그에 상세한 에러 정보 포함 가능

**코드 예시**:
```python
# backend/app/middleware/logging.py (142줄)
"headers": {k:v for k,v in request.headers.items() if k not in ['authorization']}
```

**결론**: Authorization 헤더는 제외되어 안전하나, 다른 민감 정보 노출 가능성 확인 필요

---

### 11. 공개 API 및 인증 분리 (API·인증 관련 수정 코드) ✅⚠️

**대상 코드**: 2026-02 추가/수정 — 공개 북마크 API(`bookmarks_public.py`), 프론트엔드 `api.publicBookmarks` 및 401 처리

#### 11.1 Backend (공개 API)

**상태**: **안전** (인증 우회 없음, 데이터 범위 제한 적절)

**분석**:
- **인증 의존성**: `bookmarks_public.py`에는 `get_current_user` 미사용. `Depends(get_db)`만 사용하여 인증 없이 조회 가능하도록 의도대로 구성됨.
- **데이터 범위**: CRUD `get_multi_public`, `count_public`, `get_public_by_id`는 모두 `is_public == True`, `is_deleted == False`로 필터링. 비공개·삭제된 데이터 노출 없음.
- **경로 파라미터**: `bookmark_id: UUID`로 선언되어 FastAPI가 UUID 형식 검증. 잘못된 값은 400 처리.
- **IDOR 방지**: 단건 조회 시 `is_public=True`가 아니면 404 반환. 존재 여부를 구분하지 않고 "Not Found"로 통일하여 정보 노출 최소화.
- **입력 제한**: `per_page`는 `Query(10, ge=1, le=100)`로 상한 100 적용. 과도한 요청 크기 제한.
- **라우터 순서**: `api.py`에서 공개 라우터(`/public/bookmarks`)를 인증용 북마크 라우터(`/bookmarks`)보다 먼저 등록. 경로 충돌 없음.

**코드 예시**:
```python
# backend/app/api/endpoints/bookmarks_public.py
@router.get("/{bookmark_id}", response_model=BookmarkResponse)
def get_public_bookmark(bookmark_id: UUID, db: Session = Depends(get_db)):
    bookmark = crud_bookmark.get_public_by_id(db=db, bookmark_id=bookmark_id)
    if not bookmark:
        raise HTTPException(status_code=404, detail="Not Found")
    return bookmark

# backend/app/crud/crud_bookmark.py - is_public·is_deleted 필터
def get_public_by_id(self, db: Session, *, bookmark_id) -> Optional[Bookmark]:
    return db.query(self.model).filter(
        Bookmark.id == bookmark_id,
        Bookmark.is_public == True,
        Bookmark.is_deleted == False,
    ).first()
```

**정보 노출**:
- 공개 API 응답(`BookmarkResponse`)에 `user_id` 포함. 공개 북마크의 작성자 식별용으로 허용 가능한 수준. 필요 시 익명화 검토 가능.

#### 11.2 Frontend (API·인증 분리)

**상태**: **안전** (공개 호출 시 토큰 미전송, 401 처리 일관성 유지)

**분석**:
- **공개 전용 호출**: `api.publicBookmarks.getList`, `api.publicBookmarks.getById`는 `skipAuth: true`로 호출. 요청 인터셉터에서 `config.skipAuth`이면 `Authorization` 헤더를 추가하지 않아 토큰이 공개 API로 전송되지 않음.
- **401 리다이렉트**: 응답 인터셉터에서 `error.response?.status === 401 && !error.config?.skipAuth`일 때만 `localStorage` 토큰 제거 및 `/main` 리다이렉트. 공개 API에서 401이 나와도(설정 오류 등) 인증 상태를 지우지 않아 동작이 안전함.
- **경로 구성**: `getPublicApiPrefix()`는 `getApiBaseURL()`만 사용하며 사용자 입력을 포함하지 않음. baseURL에 `/api`가 없을 때 prefix로 `/api`를 붙이는 로직은 SSRF/오염 위험 없음.
- **ID 사용**: `getById(id)`의 `id`는 목록 응답에서 오거나 URL 파라미터에서 옴. 서버에서 UUID·공개 여부를 검증하므로, 클라이언트에서 잘못된 id를 보내도 비공개 데이터는 404로만 반환됨.

**코드 예시**:
```javascript
// frontend/src/utils/api.js - 공개 API는 skipAuth
publicBookmarks: {
    getById: async (id) => {
        const response = await axiosInstance.get(`${prefix}/public/bookmarks/${id}`, {
            skipAuth: true
        });
        return response.data;
    },
},
// 401 시 skipAuth 요청은 리다이렉트/토큰 제거 제외
if (error.response?.status === 401 && !error.config?.skipAuth) {
    localStorage.removeItem('token');
    window.location.href = '/main';
}
```

#### 11.3 개선 권장 (공개 API)

**위험도**: **낮음**

| 항목 | 내용 |
|------|------|
| **Rate limiting** | 공개 API(`GET /api/public/bookmarks/`, `GET /api/public/bookmarks/{id}`)에 요청 빈도/IP당 제한 미적용. 대량 스크래핑·단순 DoS 가능성 있음. 동일 클라이언트/IP에 대한 분당·일일 제한 도입 권장. |
| **응답 필드** | `BookmarkResponse`에 `user_id` 포함. 공개 의도라면 유지 가능. 익명화가 정책이면 제거 또는 식별 불가 값으로 대체 검토. |

**결론**: 공개 API·인증 분리 구조는 **인증 우회 및 비공개 데이터 노출 없이** 적절히 구현됨. 공개 API에 rate limiting 적용 시 남용·스크래핑 방지에 유리함.

---

## 🎯 우선순위별 개선 사항

### 🔴 높은 우선순위 (즉시 조치)

1. **`.gitignore` 파일 생성**
   - `.env` 파일이 Git에 포함되지 않도록 보장
   - 로그 파일 제외

2. **환경 변수 검증**
   - `.env` 파일이 Git 저장소에 포함되어 있는지 확인
   - 포함되어 있다면 즉시 제거 및 비밀번호 변경

### 🟡 중간 우선순위 (가능한 빠른 시일 내)

3. **디버깅 코드 제거**
   - 프로덕션 환경에서 디버깅 미들웨어 제거
   - 환경 변수로 디버그 모드 제어

4. **에러 메시지 개선**
   - 프로덕션 환경에서 상세한 에러 정보 제거
   - 일반적인 에러 메시지만 반환

5. **CORS 설정 강화**
   - 프로덕션에서 필요한 메서드와 헤더만 명시적으로 허용

### 🟢 낮은 우선순위 (점진적 개선)

6. **토큰 저장 방식 개선**
   - httpOnly 쿠키 사용 검토
   - Refresh Token 도입

7. **CSRF 보호 강화**
   - CSRF 토큰 도입 검토

8. **공개 API Rate Limiting**
   - `GET /api/public/bookmarks/`, `GET /api/public/bookmarks/{id}`에 IP/클라이언트당 요청 제한 적용
   - 스크래핑·남용 완화

---

## 📝 체크리스트

### 즉시 확인 필요
- [x] `.gitignore` 파일 생성 및 `.env` 파일 제외 확인 (루트·backend·frontend 모두 `.env` 제외, `git check-ignore`로 검증 완료)
- [ ] Git 히스토리에서 `.env` 파일 포함 여부 확인
- [ ] 포함되어 있다면 비밀번호 및 SECRET_KEY 변경

### 개선 작업
- [ ] 디버깅 미들웨어 제거 또는 환경 변수로 제어
- [ ] 프로덕션 에러 메시지 일반화
- [ ] CORS 설정 강화 (프로덕션 환경)

### 장기 개선
- [ ] 토큰 저장 방식 개선 검토
- [ ] CSRF 보호 강화 검토
- [ ] 공개 API(`/api/public/bookmarks`) rate limiting 도입 검토
- [ ] 정기적인 보안 감사 계획 수립

### 공개 API·인증 분리 코드 (2026-02 반영)
- [x] 공개 전용 엔드포인트에 인증 의존성 없음 (get_current_user 미사용)
- [x] CRUD에서 is_public, is_deleted 필터로 데이터 범위 제한
- [x] 프론트엔드 공개 호출 시 skipAuth로 토큰 미전송
- [x] 401 시 skipAuth 요청은 토큰 제거·리다이렉트 제외
- [ ] 공개 API rate limiting 미적용 → 도입 권장

---

## ✅ 결론

전반적으로 **보안이 잘 구현**되어 있으며, 주요 보안 취약점(SQL Injection, XSS, 인증/인가)은 적절히 방어되고 있습니다.

**공개 API·인증 분리**(2026-02 반영)에 대해서는 **인증 우회 및 비공개 데이터 노출 없이** 설계·구현되어 있으며, 프론트엔드에서 공개 전용 호출 시 토큰을 보내지 않고 401 처리도 일관되게 유지됩니다. 다만 공개 API에 rate limiting이 없어 스크래핑·남용 가능성이 있으므로, 장기적으로 제한 도입을 권장합니다.

**가장 중요한 개선 사항**은 **환경 변수 파일 관리**입니다. `.gitignore` 파일을 생성하고 `.env` 파일이 Git에 포함되지 않았는지 확인하는 것이 최우선 과제입니다.

나머지 개선 사항들은 점진적으로 적용하면 됩니다.

---

**보고서 작성일**: 2026-02-12  
**공개 API·인증 분리 반영**: 2026-02-14  
**다음 검토 권장일**: 환경 변수 관리 개선 후 및 공개 API rate limiting 도입 시
